
**问题： jvm 内存结构**

**问题： 什么是类加载器？类加载器有哪些？简述类加载的整个过程**

- 什么是类加载器？ 参考 https://blog.csdn.net/qq_42594368/article/details/82431906

  java类加载器是 java运行时环境的一部分，负责动态加载java类到java虚拟机的内存空间中。类通常是按需加载，即第一次使用该类时才加载。
  
  ![类加载器的层次](/images/classloader.png)

- 类加载器
  
  - 启动类加载器（Bootstrap ClassLoader）：最顶层的类加载器，负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。
  
  - 扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。  
  
  - 应用程序类加载器(Application ClassLoader)：也叫做系统类加载器，可以通过getSystemClassLoader()获取，负责加载用户路径（classpath）上的类库。如果没有自定义类加载器，一般这个就是默认的类加载器。

  - 用户自定义来加载器，父类加载器肯定为AppClassLoader。通过继承 java.class.ClassLoader 实现。
  
- 类加载机制

  - 全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
  - 双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
  - 缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
  
- 双亲委派机制
  
  其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
  
  ![双亲委派](/images/shuangqingweipai.png)


- 类加载过程 参考：https://blog.csdn.net/noaman_wgs/article/details/74489549
  
  JVM类加载分为5个过程：加载，验证，准备，解析，初始化，使用，卸载，如下图所示：
  
  ![类加载器的层次](/images/classloading.png)
  
  1.1 加载
  
  加载主要是将.class文件（并不一定是.class。可以是ZIP包，网络中获取）中的二进制字节流读入到JVM中。
  
  在加载阶段，JVM需要完成3件事：
  - 1）通过类的全限定名获取该类的二进制字节流；
  - 2）将字节流所代表的静态存储结构转化为方法区的运行时数据结构；
  - 3）在内存中生成一个该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
  
  1.2 连接
  
  1.2.1 验证
  
  验证是连接阶段的第一步，主要确保加载进来的字节流符合JVM规范。
  
  验证阶段会完成以下4个阶段的检验动作：
  
  - 1）文件格式验证
  - 2）元数据验证(是否符合Java语言规范)
  - 3）字节码验证（确定程序语义合法，符合逻辑）
  - 4）符号引用验证（确保下一步的解析能正常执行）
  
  1.2.2 准备
  
  准备是连接阶段的第二步，主要为静态变量在方法区分配内存，并设置默认初始值。
  
  1.2.3 解析
  
  解析是连接阶段的第三步，是虚拟机将常量池内的符号引用替换为直接引用的过程。
  
  1.3 初始化
  
  初始化阶段是类加载过程的最后一步，主要是根据程序中的赋值语句主动为类变量赋值。
  
  > 注：
  > 1）当有父类且父类未初始化的时候，先去初始化父类；
  > 2）再进行子类初始化语句。
  
  什么时候需要对类进行初始化？
  
  - 1）使用new该类实例化对象的时候；
  - 2）读取或设置类静态字段的时候（但被final修饰的字段，在编译器时就被放入常量池的静态字段除外static final）；
  - 3）调用类静态方法的时候；
  - 4）使用反射Class.forName(“xxxx”)对类进行反射调用的时候，该类需要初始化；
  - 5） 初始化一个类的时候，有父类，先初始化父类（注：1. 接口除外，父接口在调用的时候才会被初始化；2.子类引用父类静态字段，只会引发父类初始化）；
  - 6） 被标明为启动类的类（即包含main()方法的类）要初始化；
  - 7）当使用JDK1.7的动态语言支持时，如果一个java.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。
  
  以上情况称为对一个类进行主动引用，且有且只要以上几种情况需要对类进行初始化。
  
  > 对于一个final类型的静态变量，如果该变量的值在编译时就可以确定下来，那么这个变量相当于“宏变量”。Java编译器会在编译时直接把这个变量出现的地方替换成它的值，因此即使程序使用该静态变量，也不会导致该类的初始化。反之，如果final类型的静态Field的值不能在编译时确定下来，则必须等到运行时才可以确定该变量的值，如果通过该类来访问它的静态变量，则会导致该类被初始化。
   

**问题： 什么是双亲委派模式？有什么作用？（有没有能破坏这个模式的方法？）**

双亲委派模式见上一个问题的答案

双亲委派的作用：

- 双亲委派模型很好的解决了各个类加载器加载基础类的统一性问题。即越基础的类由越上层的加载器进行加载。

- 其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。

双亲委派遇到的问题： 若加载的基础类中需要回调用户代码，而这时顶层的类加载器无法识别这些用户代码，这时就需要破坏双亲委派模型了。

破坏双亲委派模型的例子：

- JNDI破坏双亲委派模型
  JNDI是Java标准服务，它的代码由启动类加载器去加载。但是JNDI需要回调独立厂商实现的代码，而类加载器无法识别这些回调代码（SPI）。
  为了解决这个问题，引入了一个线程上下文类加载器。 可通过Thread.setContextClassLoader()设置。
  利用线程上下文类加载器去加载所需要的SPI代码，即父类加载器请求子类加载器去完成类加载的过程，而破坏了双亲委派模型。

- Spring破坏双亲委派模型
  Spring要对用户程序进行组织和管理，而用户程序一般放在WEB-INF目录下，由WebAppClassLoader类加载器加载，而Spring由Common类加载器或Shared类加载器加载。
  那么Spring是如何访问WEB-INF下的用户程序呢？
  使用线程上下文类加载器。 Spring加载类所用的classLoader都是通过Thread.currentThread().getContextClassLoader()获取的。当线程创建时会默认创建一个AppClassLoader类加载器（对应Tomcat中的WebAppclassLoader类加载器）： setContextClassLoader(AppClassLoader)。
  利用这个来加载用户程序。即任何一个线程都可通过getContextClassLoader()获取到WebAppclassLoader。

- Tomcat类加载架构（破坏双亲委派模型）
  
  ![Tomcat类加载架构](/images/tomcatclassloader.png)

  Tomcat目录下有4组目录：
  
  - /common目录下：类库可以被Tomcat和Web应用程序共同使用；由 Common ClassLoader类加载器加载目录下的类库；
  - /server目录：类库只能被Tomcat可见；由 Catalina ClassLoader类加载器加载目录下的类库；
  - /shared目录：类库对所有Web应用程序可见，但对Tomcat不可见；由 Shared ClassLoader类加载器加载目录下的类库；
  - /WebApp/WEB-INF目录：仅仅对当前web应用程序可见。由 WebApp ClassLoader类加载器加载目录下的类库；
  - 每一个JSP文件对应一个JSP类加载器。


**问题： 垃圾回收（垃圾回收算法，垃圾回收器有什么？）**

**问题： 类的生命周期**

**问题： Java对象创建过程**

**问题： 描述一下JVM加载class文件的原理机制？**

**问题： Full GC 、 Major GC 、Minor GC 之间区别？什么时候触发 Full GC ？**

JVM内存空间图解

![JVM内存空间图解](/images/jvm.webp)

程序计数器：线程私有。是一块较小的内存，是当前线程所执行的字节码的行号指示器。是Java虚拟机规范中唯一没有规定OOM（OutOfMemoryError）的区域。

Java栈：线程私有。生命周期和线程相同。是Java方法执行的内存模型。执行每个方法都会创建一个栈帧，用于存储局部变量和操作数（对象引用）。局部变量所需要的内存空间大小在编译期间完成分配。所以栈帧的大小不会改变。存在两种异常情况：若线程请求深度大于栈的深度，抛StackOverflowError。若栈在动态扩展时无法请求足够内存，抛OOM。

Java堆：所有线程共享。虚拟机启动时创建。存放对象实力和数组。所占内存最大。分为新生代（Young区），老年代（Old区）。新生代分Eden区，Servior区。Servior区又分为From space区和To Space区。Eden区和Servior区的内存比为8:1。 当扩展内存大于可用内存，抛OOM。

方法区：所有线程共享。用于存储已被虚拟机加载的类信息、常量、静态变量等数据。又称为非堆（Non – Heap）。方法区又称“永久代”。GC很少在这个区域进行，但不代表不会回收。这个区域回收目标主要是针对常量池的回收和对类型的卸载。当内存申请大于实际可用内存，抛OOM。

本地方法栈：线程私有。与Java栈类似，但是不是为Java方法（字节码）服务，而是为本地非Java方法服务。也会抛StackOverflowError和OOM。

Minor GC ：清理新生代 ; 即发生在新生代（包括Eden区和Survivor区）的垃圾回收操作，当新生代无法为新生对象分配内存空间的时候，会触发Minor GC。

Major GC ：清理Tenured区，用于回收老年代，出现Major GC通常会出现至少一次Minor GC。

Full GC ： 针对整个新生代、老生代、元空间（metaspace，java8以上版本取代perm gen）的全局范围的GC。Full GC不等于Major GC，也不等于Minor GC+Major GC，发生Full GC需要看使用了什么垃圾收集器组合，才能解释是什么样的垃圾回收。

Full GC触发条件：

（1）调用System.gc时，系统建议执行Full GC，但是不必然执行

（2）老年代空间不足

（3）方法区空间不足

（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存

（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小


**问题：JVM的永久代中会发生垃圾回收么？**

永久代的垃圾回收主要包括类型的卸载和废弃常量池的回收。当没有对象引用一个常量的时候，该常量即可以被回收。而类型的卸载更加复杂。必须满足一下三点，该类型的所有实例都被回收了，该类型的ClassLoader被回收了，该类型对应的java.lang.Class没有在任何地方被引用，在任何地方都无法通过反射来实例化一个对象。


**问题： 引起类加载操作的行为有哪些？**

类的加载方式分为：隐式加载和显式加载

- 隐式加载：

  隐式加载指的是程序在使用new 等方式创建对象时，会隐式的调用类的加载器（classload）把对应的类加载到JVM中。

- 显式加载：

  显式加载指的是通过直接调用Class.forName()方法来把所需的类加载到JVM中。
  

**问题： 什么是内存溢出， 内存泄露？ 他们的区别是什么？**

**问题： JVM 预定义的类加载器有哪几种？分别什么作用？**


**问题：GC是什么，为什么要有GC？**

GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或者系统不稳定，甚至崩溃；java提供的GC功能可以自动监测对象是否超过作用域
从而达到自动回收内存的目的，java语言没有提供释放已分配内存的显式操作方法。


**问题：垃圾回收的优点，并考虑2中回收机制**

优点：

- 可以有效的防止内存泄露，有效的使用可以使用的内存。

- 垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。


回收机制：分代复制垃圾回收，标记垃圾回来，增量垃圾回收



**问题：如何判断一个对象是否存活？（或者GC对象的判定方法）**

参考文章：https://www.cnblogs.com/java-spring/p/9855129.html

判断一个对象是否存活有两种方式： 

- 1、引用计数法

  给对象中设置一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；当一个对象的引用计数器为0时，说明此对象没有被引用。

  引用计数法有一个缺陷就是无法解决循环引用的问题，所以主流的虚拟机都没有采用这种算法。

- 2、可达性算法（引用链法）
  
  通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
  
  ![可达性分析算法判定对象是否可回收](/images/referencechain.png)

  在Java语言中，可作为GC Roots的对象包括下面几种：
  
  - 虚拟机栈（栈帧中的本地变量表）中引用的对象。
  - 方法区中类静态属性引用的对象。
  - 方法区中常量引用的对象。
  - 本地方法栈中JNI（即一般说的Native方法）引用的对象。
  
  需要说明的是，即使再可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：
  
    - 1、对象在进行可达性分析后被发现不可达，它将会被第一次标记并进行一次筛选，筛选的条件是此对象是
        否有必要执行finalise()方法，当对象没有覆盖finalize()方法或者finalize()方法已经被JVM调用过，那么就没必要执行finalize()方法；
  
    - 2、如果被判定为有必要执行finalize()方法，那么此对象将会放置在一个叫做F-Quenen的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的Finalize线程去触发这个方法。finalize()方法是对象逃脱死亡的
         最后一次机会，稍后GC将对F-Quenen中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关系即可，
         譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量，那么在第二次标记时它将被移出“即将回收”集合；如果对象这时候还么有成功逃脱，那他就会真的被回收了。


**问题：垃圾回收器的基本原理是什么？还有垃圾回收器可以马上回收内存吗？并且有什么办法可以主动通知虚拟机进行垃圾回收呢？**

对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址，大小及使用情况。通常GC采用有向图的方式记录和管理堆（head）中的所有对象。
通过这种方式确定哪些对象是“可达的”，哪些对象是“不可达”的，当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。

gc可以马上回收内存，

程序可以使用system.gs()回收，通知GC运行，但是java语言规范并不保证GC一定会执行。


**问题：java中会存在内存泄露吗，请简单描述**

内存泄露是指不再被使用的对象或者变量一直被占据在内存中。理论上，java的GC机制会自动收回掉不再被使用的对象；但是即使这样，java也还存在着内存泄露的情况。

- 1、长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露（缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。）

- 2、如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。

- 3、当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。








