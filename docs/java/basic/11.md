

- 面向对象的特征有哪些方面

主要有以下四方面：

1.抽象：抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处。抽象包括两个方面，一是过程抽象，二是数据抽象。

2.继承：子类继承父类，子类共享父类属性和方法的同时可以扩展自己的属性和方法。提高了软件的可重用性和可扩展性                      。

3.封装：把对象的属性和方法结合成一个整体，并隐藏内部的实现细节，提供对外的访问接口。

4. 多态性：不同对象对同一消息做出不同的响应处理，主要实现：子类继承父类，子类重写父类的方法，父类的引用指向子类的对象。



- &和&&的区别

&:”与”是位运算符，表示按位与运算，左边是false右边还执行。&&:”并且”是逻辑运算符，表示逻辑与（and），左边是true右边才执行


- 是否可以继承String类

String类是final类故不可以继承，final是最终的。


- try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后

会执行，在return前执行


- 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？

不对，有相同的hash code，因为equals比较hash code值相同才会返回true


- 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递
   
是值传递。Java 编程语言只有值传递参数。

*值传递：是对所传递参数进行一次副本拷贝，对参数的修改只是对副本的修改，函数调用结束，副本丢弃，原来的变量不变(即实参不变)，基本数据类型都是值传递。

*引用传递：参数被传递到函数时，不复制副本，而是直接将参数自身传入到函数，函数内对参数的任何改变都将反映到原来的变量上。

*对于基本类型，传递的是基本类型的值，而对于引用类型传递的是地址。


- swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上

在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。


- String、StringBuffer和StringBuilder区别

String 是被final修饰的，长度是不可变的。StringBuffer和StringBuilder长度都是可变的

三者在执行速度方面的比较：StringBuilder > StringBuffer > String

如果要操作少量的数据用 String

单线程操作字符串缓冲区 下操作大量数据 = StringBuilder

多线程操作字符串缓冲区 下操作大量数据 = StringBuffer

StringBuffer是线程安全的有锁，StringBuilder是线程不安全的，string是线程安全的因为final最终的。如果最后需要String，那么使用StringBuffer的toString()方法



- 谈谈final, finally, finalize的区别

final—用于声明属性、类和方法，分别表示属性不可变，方法不可覆盖（重写），类不可被继承

finally—是异常处理语句结构的一部分，表示总是执行

finalize—是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法用于回收资源，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等


- 垃圾回收的优点和原理。并考虑2种回收机制

Java语言中一个显著的特点就是引入了垃圾回收机制，垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。

对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。

回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。

*分代复制垃圾回收：根据对象的生命周期不同，分为年轻代、年老代、持久代，分区回收。

*标记垃圾回收：一、标记阶段，标记所有可访问对象；二、收集阶段，标记垃圾回收算法回收首页未标记的对象，在此过程中会出现程序无响应。

*增量垃圾回收：主要是为了解决标记垃圾回收时长停顿的问题，设置GC最多中断的时间10ms，分时间段来回收垃圾。


- 一个".java"源文件中是否可以包括多个类（不是内部类）？有什么限制？

可以。只有一个public类，并且类名与文件名相同。


- java中会存在内存泄漏吗，请简单描述。

内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。检查java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。

会。长生命周期的对象持有短生命周期对象的引用就有可能发生内存泄露。比如像加载了一个对象放在缓存中而一直没有引用。


- 内存溢出和内存泄漏的区别

系统已经不能再分配出你所需要的空间，比如你需要100M的空间，系统只剩90M了，这就叫内存溢出。

内存泄露是对象没有引用的时候没有被回收，一直占据着内存。


- 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收

对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。


- 如何避免内存泄漏、溢出

1、尽早释放无用对象的引用
好的办法是使用临时变量的时候，让引用变量在推出活动域后自动设置为null，暗示垃圾收集器来收集该对象，防止发生内存泄漏。

2、程序进行字符串处理时，尽量避免使用String，而应该使用StringBuffer。
因为String类是不可变的，每一个String对象都会独立占用内存一块区域。

3、尽量少用静态变量
因为静态变量是全局的，存在方法区，GC不会回收。（用永久代实现的方法区，垃圾回收行为在这个区域是比较少出现的，垃圾回收器的主要目标是针对常量池和类型的卸载）

4、避免集中创建对象，尤其是大对象，如果可以的话尽量使用流操作
JVM会突然需要大量neicun，这时会出发GC优化系统内存环境

5、尽量运用对象池技术以提高系统性能
生命周期长的对象拥有生命周期短的对象时容易引发内存泄漏，例如大集合对象拥有大数据量的业务对象的时候，可以考虑分块进行处理，然后解决一块释放一块的策略。

6、不要在经常调用的方法中创建对象，尤其忌讳在循环中创建对象
可以适当的使用hashtable，vector创建一组对象容器，然后从容器中去取这些对象，而不用每次new之后又丢弃。

7、优化配置



- 是否可以从一个static方法内部发出对非static方法的调用？

不可以,如果其中包含对象的method()；不能保证对象初始化.


- 什么是值传递，什么是引用传递?

*值传递：是对所传递参数进行一次副本拷贝，对参数的修改只是对副本的修改，函数调用结束，副本丢弃，原来的变量不变(即实参不变)，基本数据类型都是值传递。

*引用传递：参数被传递到函数时，不复制副本，而是直接将参数自身传入到函数，函数内对参数的任何改变都将反映到原来的变量上。


- 一个javabean的生命周期

加载、验证、准备、初始化、引用和卸载这六个过程

加载类，验证语法，准备（分配内存），初始化（父子类构造函数，赋值），引用，卸载（垃圾回收）


- 简述Objiect类的几个方法

①clone()：protected Object clone()创建并返回此对象的一个副本。

②equals()：boolean equals(Object obj)指示其他某个对象是否与此对象“相等”。

③finalize()：protected void finalize()当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。

④getClass()：Class<?> getClass()返回此 Object 的运行时类。

⑤hashCode()：int hashCode()返回该对象的哈希码值。

⑥notify()：void notify()唤醒在此对象监视器上等待的单个线程。

⑦notifyAll()：void notifyAll()唤醒在此对象监视器上等待的所有线程。

⑧toString()：String toString()返回该对象的字符串表示。

⑨wait()：void wait()在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。

void wait(long timeout)在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线程等待。

void wait(long timeout, int nanos)在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。


- int 和 Integer 有什么区别

Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。int是java的原始数据类型初始值是0，Integer是java为int提供的封装类，初始值是null。Java为每个原始类型提供了封装类，8大数据类型首字母大写就是封装类。


- 数组有没有length()这个方法? String有没有length()这个方法

数组没有length()这个方法，有length的属性。String有length()这个方法


- String s = new String("xyz");创建了几个String Object

两个，一个字符对象，一个字符对象引用对象


- short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错

short s1 = 1; s1 = s1 + 1; （s1+1运算结果是int型，需要强制转换类型会报错）short s1 = 1; s1 += 1;（可以正确编译）自动转型小转大，大转小必须强制转型

i=i+2 比 i+=2多了一次对变量 i 的运算。i=i+2是先进行i+2的运算得出一个结果，再赋值给i。i+=2就是先赋值然后在进行加法，因此运算效率高，结果是一样的。


- String是最基本的数据类型吗?

基本数据类型包括整数型4种：byte（1字节8位）、short（2字节16位）、int（4字节32位）、long（8字节64位）；浮点型2种：float（4季节32位）、double（8字节64位）；布尔型一种：boolean（1字节8位）；字符型一种：char（2字节16位）。

1字节=8位=8bit  1个汉子=2字节  这里的位是指二进制的位数

java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类


- char型变量中能不能存贮一个中文汉字?为什么?

是能够定义成为一个中文的，因为java中以unicode编码，一个char占16个字节，所以放一个中文是没问题的


- float型float f=3.4是否正确?

答:不正确。精度不准确，有小数点的默认是double，应该用强制类型转换，如下所示：float f=(float)3.4或float f=3.4f


- error和exception有什么区别

error 是不可控制的unchecked，用来表示系统错误或底层资源错误，如果有可能应该在系统级别被捕捉

exception 是可控的或不可控的（黑客攻击），表示程序级的错误，应该在程序级别被捕捉


- 什么是反射？

反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。


- 哪里用到反射机制？

JDBC中，利用反射动态加载了数据库驱动程序。

Web服务器中利用反射调用了Sevlet的服务方法。

Eclispe等开发工具利用反射动态刨析对象的类型与结构，动态提示对象的属性和方法。

很多框架都用到反射机制，注入属性，调用方法，如Spring。


- 反射机制的优缺点？

优点：可以动态执行，在运行期间根据业务功能动态执行方法、访问属性，最大限度发挥了java的灵活性。

缺点：对性能有影响，这类操作总是慢于直接执行java代码。


- 数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？

Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。

Array大小是固定的，ArrayList的大小是动态变化的。

ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。

对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。


- Collection 和 Collections的区别

Collection是集合类的上级接口，继承与他的接口主要有Set 和List.

Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作


- Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别

Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等

equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值 


- ArrayList和Vector的区别,HashMap和Hashtable的区别

就ArrayList与Vector主要从二方面来说.

一.同步性:Vector是线程安全的，也就是说是同步的，而ArrayList是线程序不安全的，不是同步的

二.数据增长:当需要增长时,Vector默认增长为原来一培，而ArrayList却是原来的一半

就HashMap与HashTable主要从三方面来说。

一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现

二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的

三.值：只有HashMap的key或value可以为空值


- 说出ArrayList,Vector, LinkedList的存储性能和特性

ArrayList,Vector底层数据结构都是数组，查询快，增删慢。ArrayList线程不安全，Vector线程安全但是效率慢。LinkedList线程安全，底层数据结构是链表，查询慢，增删快。

-HashMap和Hashtable的区别

HashMap和Hashtable底层数据结构都是哈希表。HashMap线程非安全，可以允许空值，效率高。HashTable线程安全，效率低。


- ArrayList集合加入1万条数据，应该怎么提高效率

因为ArrayList的底层是数组实现,并且数组的默认值是10,如果插入10000条要不断的扩容,耗费时间,所以我们调用ArrayList的指定容量的构造器方法ArrayList(int size) 就可以实现不扩容,就提高了性能。


- abstract class和interface有什么区别

1：抽象类用abstract关键字，接口用interface


2：接口只能定义方法，抽象类不仅可以定义抽象方法，还可以有实现方法

3：抽象类只能单一继承，接口可以被多重实现，抽象定义的类叫抽象类，抽象类字段默认friendly（本包可见），用abstract关键字定义抽象类和抽象方法。


4：抽象层次不同，抽象类是对类抽象，而接口是对行为的抽象。

抽象方法没有主体，有抽象方法的一定是抽象类。抽象类不一定必须有抽象方法，抽象类可以定义和实现。抽象类只能被单一继承extends。抽象类抽象方法不能使用private，因为不能被子类继承。抽象方法不能使用static，因为方法没有主体没有意义。

接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。接口可以被多重实现implements，接口的字段默认为public static final。instanceof 运算符可以用来决定某对象的类是否实现了接口

当存在继承关系时用抽象类，只需要使用单一功能用接口。

抽象类与接口都用于抽象，但是抽象类(JAVA中)可以有自己的部分实现，而接口则完全是一个标识(同时有多重继承的功能)。


- 抽象类abstract的方法method是否可同时是static,是否可同时是native，是否可同时是synchronized

都不能，abstract是没有被实现的，而static一定要被实现的。Synchronized是需要同步的，abstract只有被子类继承的时候才能添加同步。Native本地方法，它把具体的实现交给了本地的函数库，没有通过虚拟机，是java与其他语言通信的一种机制。与抽象方法把实现交给子类实现冲突。


- 构造器Constructor是否可被override

构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载Overloading（有参、无参、多参的构造函数）


- 匿名内部类（Anonymous Inner Class） 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)

匿名的内部类是没有名字的内部类。不能extends(继承) 其它类，但一个内部类可以作为一个接口，由另一个内部类实现


- java中实现多态的机制是什么？

方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。


- 什么是多线程上下文切换

多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。


- wait()和sleep()的区别？

1）Sleeep来自Thread类，wait()来自Object类。

2）调用sleep()过程中，线程不会释放对象锁，wait()方法会释放。

3）sleep()睡眠后不让出系统资源，wait()让出资源

4）sleep(millssecond)需要指定一个睡眠时间，时间一到会自动唤醒


- start()方法和run()方法的区别

只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。


- 线程的生命周期

新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态。

*新建状态，当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值

*就绪状态，当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行

*运行状态，如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态

*阻塞状态，当处于运行状态的线程失去所占用资源之后，便进入阻塞状态

*死亡状态，线程在run()方法执行结束后进入死亡状态。此外，如果线程执行了interrupt()或stop()方法，那么它也会以异常退出的方式进入死亡状态。


- Java中实现线程阻塞的方法

（1）线程睡眠：Thread.sleep (long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。

（2）线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait() 一样。wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.

（3）线程礼让，Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.

（4）线程自闭，join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。


- 什么是死锁

死锁是指两个以上的进程在执行过程中，由于竞争资源或通信造成的一种阻塞现象，若无外力作用，它们将无法推行下去。


- 产生死锁的条件

1.互斥条件：一个资源每次只能被一个进程使用。

2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。

4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

- 如何避免死锁

1、不让产生死锁的四个条件同时成立

2、合理分配资源

3、使用银行家算法，如果该进程请求的资源当前操作系统余量可以满足，就分配


- 线程间的通信方式

（1）管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。

（2）命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关 系 进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。

（3）信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送 信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。

（4）消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺

（5）共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。

（6）内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。

（7）信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。

（8）套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。


- 线程的sleep()和yield()方法有什么区别？

1）sleep()给其它线程运行机会不会考虑线程优先级，yield()只会给相同优先级或更高优先级的线程机会 

2）线程执行sleep()方法后进入阻塞状态，而执行yeild()进入就绪状态

3）sleep()方法需要抛出异常interupdateException，而yeild()不用抛异常

4）sleep()比yield()有更好的移植性


- 如何设置线程的优先级

线程. setPriority()方法来设置线程的优先级，参数是1~10，默认是5。优先级和线程抢到资源的概率没有关系。结合yeild()就有用了。


- 什么是乐观锁和悲观锁？

1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。

2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。


- java常见的几种锁？

1）自旋锁:自旋锁顾名思义，它会等待一定时间（自旋），在这期中会什么都不做就是等资源被释放，好处在于没有了内核态用户态切换的效率损失，但是如果它一直不能访问到资源的话就会一直占用cpu资源，所以它会循环一段时间后进入阻塞状态。

重量级锁:synchronized就是重量级锁的实现机制，抢不到资源的进程会进入阻塞状态

2）偏向锁:顾名思义，它会偏向第一个访问资源的进程，如果说只有一个进程执行同步代码块，那么就会上个偏向锁，如果有其他线程抢占资源，那么就会升级为轻量级锁

轻量级锁:偏向锁升级之后就是轻量级锁，锁只可以升级而不可以降级。轻量级锁中的其他进程会进入自选状态，如果说自选失败，就会升级会重量级锁

3）公平，非公平锁:主要是指线程是否先来后到拿到锁，synchronized是非公平的，而ReentrantLock默认非公平，可以设置为公平锁

4）悲观锁:总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

5）乐观锁:总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制（数据库中）和CAS算法实现














