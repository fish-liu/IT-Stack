
参考：https://blog.csdn.net/crazymakercircle/article/details/85956246

分布式锁

----------------------------


###  简介

在我们进行单机应用开发，涉及并发同步的时候，我们往往采用synchronized或者Lock的方式来解决多线程间的代码同步问题。但当我们的应用是分布式集群工作的情况下，那么就需要一种更加高级的锁机制，来处理种跨机器的进程之间的数据同步问题。
这就是分布式锁。


### 预备知识

CAP理论



### 公平锁和可重入锁 模型


分布式锁的概念和原理，比较抽象难懂。如果用一个简单的故事来类比，估计就简单多了。

很久以前，在一个村子有一口井，水质非常的好，村民们都抢着取井里的水。井就那么一口，村里的人很多，村民为争抢取水打架斗殴，甚至头破血流。

问题总是要解决，于是村长绞尽脑汁，最终想出了一个凭号取水的方案。井边安排一个看井人，维护取水的秩序。

说起来，秩序很简单，取水之前，先取号。号排在前面的，就可以先取水。先到的排在前面，那些后到的，没有排在最前面的人，一个一个挨着，在井边排成一队。取水示意图如下 ：

![lock1](/images/lock1.jpg)


这种排队取水模型，就是一种锁的模型。排在最前面的号，拥有取水权，就是一种典型的独占锁。另外，先到先得，号排在前面的人先取到水，取水之后就轮到下一个号取水，至少，看起来挺公平的，说明它是一种公平锁。

在公平独占锁的基础上，再进一步，看看可重入锁的模型。

假定，取水时以家庭为单位，哪个家庭任何人拿到号，就可以排号取水，而且如果一个家庭有一个人拿到号，其它家人这时候过来打水不用再取号。新的排号取水示意图如下 ：

![lock2](/images/lock2.jpg)


如上图的1号，老公有号，他的老婆来了，直接排第一个，妻凭夫贵。再看上图的2号，父亲正在打水，他的儿子和女儿也到井边了，直接排第二个，这个叫做子凭父贵。 等等，如果是同一个家庭，可以直接复用排号，不用重新取号从后面排起。

以上这个故事模型，就是可以重入锁的模型。只要满足条件，同一个排号，可以用来多次取水。在锁的模型中，相当于一把锁，可以被多次锁定，这就叫做可重入锁。



### 分布式锁的实现方式

- [基于zookeeper临时节点的分布式锁](distri/lock/zklock.md)

- [基于redis的分布式锁](distri/lock/redislock.md)

- [基于数据的乐观锁实现分布式锁](distri/lock/dblock.md)

- Chubby ： Google公司实现的粗粒度分布式锁服务，底层利用了Paxos一致性算法。


