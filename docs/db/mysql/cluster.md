

本文转载自 ：https://blog.csdn.net/u010013573/article/details/88373274 和 https://blog.csdn.net/u010013573/article/details/88375380



### 概念

**可拓展性和高可用**

MySQL主从复制主要用于数据读写分离的场景，即主库负责数据的写入，从库负责数据的读取，从而实现访问流量的分流，提高系统的整体负载能力。同时由于数据在主从节点都进行了冗余保存，避免了数据单点问题，提高了数据安全性。所以MySQL主从复制是可拓展性和高可用方面的一种实现方案。


**基本工作流程**

主从复制的基本工作过程为：主库处理所有的写请求，然后将该写请求异步复制给一台或多台从库，从库执行该写请求，从而保证与主库数据的最终一致性。具体过程如图所示：

![Mysql主从](/images/cluster.png)


**分布式数据一致性**

由于主从复制是一种异步复制的过程，故从库数据可能与主机数据存在延迟，数据落后于主库，故不是数据强一致性的实现，而是最终一致性的一种实现。故适合于能容忍一定的数据延迟性的应用场景。如果既需要系统的高负载处理能力，即读写流量很大时依然能保证高性能处理能力，又需要保证数据强一致性，则通常需要使用分库分表来实现。



### 主从复制原理

**二进制日志binlog**

  - MySQL主从复制是基于二进制日志binlog实现的，即使用二进制日志记录数据的修改操作，然后从主库同步该二进制日志给从库，从库根据二进制日志来执行对应的数据修改操作。

  - 二进制日志的详细分析：：[MySQL二进制日志binlog的设计与实现](db/mysql/binlog.md)

**复制线程**

  - 由以上分析可知，主从复制是基于二进制日志实现的，主库异步复制二进制日志给从库，所以在主库从库之间首先需要建立一个连接，同时从库需要主动连接主库。

  - 当从库连接主库时，除了建立连接之外，主库会创建一个复制线程来读取二进制日志并基于该连接传送给从库，从库也需要创建一个复制线程来接收主库传送过来的二进制日志，然后在从库保存为relay log，即重放日志。同时从库还需要一个对relay log进行解析并在从库执行对应的SQL的SQL线程。故这个过程涉及到了三个线程来完成主从之间的复制。

  - 从库使用两个线程主要是为了加快二进制日志的同步和解析执行，降低数据延迟性。同时由于二进制日志同步加快，降低了主库在产生了大量二进制日志还没来得同步给从库而出现故障导致数据丢失的风险。

**主从复制的基本步骤**

  1、在主库创建用于复制的用户并授予复制权限
  
  ```linux
  mysql> create user 'repl'@'192.168.0.1' identified by '123456';
  Query OK, 0 rows affected (0.08 sec)
  
  mysql> grant replication slave on *.* to 'repl'@'192.168.0.1';
  Query OK, 0 rows affected (0.01 sec)
  ```

  2、创建主库某一时刻的完整数据快照备份和获取该时刻binlog的log position
  
  - 数据库备份的获取：

    - 如果可以停库的，则可以先停机获取全库冷备份的方式，具体为copy主库的全部数据库文件和日志文件到从库的指定位置；

    - 如果不可以停库的，则需要通过mysqldump或者其他工具来创建该时刻的数据库快照，同时为了保证数据的完整性和数据一致性，需要使用FLUSH TABLES WITH READ LOCK命令来锁住所有表禁止写操作。如下为加锁和解锁操作：

    ```linux
    mysql> FLUSH TABLES WITH READ LOCK;
    Query OK, 0 rows affected (0.00 sec)
    
    mysql> UNLOCK TABLES;
    Query OK, 0 rows affected (0.00 sec)
    ```

  - binlog的log position表示该时刻主库的binlog写到什么位置了，具体为在主库执行：show master status命令来获取。对于停机需要在重启还没写入操作之前执行，对于非停库方式，则在锁表期间执行。命名如下：

    ```linux
    mysql> show master status; 
    +——————+———-+————–+——————+ 
    | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | 
    +——————+———-+————–+——————+ 
    | mysql-bin.000001 | 79 | | | 
    +——————+———-+————–+——————+ 
    1 row in set (0.00 sec)
    ```

  3、将数据快照导入从库
  
  - 从库数据导入的方式需要根据主库所提供的数据库快照的格式来决定。

  4、启动从库并连接主库，并设置好从库对主库的binlog的log position

  - 启动从库后，主要通过执行CHANGE MASTER TO命令来连接主库，如下：

    ```linux
    mysql> CHANGE MASTER TO
        -> MASTER_HOST='192.168.0.1',
        -> MASTER_USER='repl',
        -> MASTER_PASSWORD='123456',
        -> MASTER_LOG_FILE='mysql-bin.000001',
        -> MASTER_LOG_POS=79;
    ```



### 主从复制架构模式

- MySQL主从复制主要用于实现读写分离，所以主从架构一般为一主多从，即主库负责处理所有的写入请求，一个或多个从库负责处理所有的读请求，从而分散读写流量，实现读数据的高可用。除此之外，如果从库很多造成了主库复制负载太大，也可以考虑采用级联复制，即从库既作为主库的从库，也作为下一级从库的主库，从而降低主库的负载。

- 以上架构都是针对读实现高可用，在主库写方面还是存在单点问题，故也可以基于MySQL主从复制实现一个双主架构，实现主库写的高可用。

- 在双主架构基础上，还可以继续添加从库，从而实现读写分离和读写的高可用。


#### Master-Slaves：一主多从架构

- 一主多从架构是最简单的主从架构模式，由于从库直接复制主库，故在系统负载良好的情况下，从库的数据延迟是最小的，基本与主库保持实时一致性。所以这种架构模式也是生产环境最常用于实现读写分离的一种主从架构。具体架构示意图如下：（图片均引自《MySQL性能调优与架构设计》

![Mysql主从](/images/cluster1.png)

- 这种架构模式存在的问题就是主库还是单点的，即没有实现主库写的高可用，一种方案是当主库停机时，将从库切换为主库，但是这样当主库重新起来，需要切换回来时，由于主库没有从库的binlog position，即不知道需要从当前担任主库的从库的什么位置复制数据，故需要重新搭建主机复制环境，这样会带来许多额外的工作量和风险。所以为了解决这个问题，实现自动切换和恢复，则可以使用双主架构。


#### Master-Master：双主架构

- 双主架构是实现主库写高可用的一种架构模式，两个主库互为对方的从库，两个主库均可以执行写操作，然后复制给对方。

- 主库停机维护：由于双方都有对方的binlog position，即知道当前复制到对方什么位置了，故当其中一方停机可以使用另外一方来作为主库，当停机的主库重启恢复回来时，可以从原来的binlog position继续复制当前的主库的数据，实现自动切换恢复。

- 主库故障自动切换：可以结合第三方的高可用工具HA来实现当其中一个主库挂掉时，自动切换到另外一个主库，实现故障自动切换和高可用。


**循环复制问题**

- 在这种模式下，由于双方都是主库，故均会将写操作记录到二进制日志中并复制给对方，这样会存在循环复制的问题。

- 故为了解决这个问题，MySQL在设计中，在搭建主从复制时，各个库需要指定自己的server-id，并且不能相同，所以通过该server-id每个主库可以判断出这个写操作是否是自己产生的，如果是则忽略复制过来的写操作，如下为使用MySQL自带的mysqlbinlog工具查看的二进制日志的内容，其中包含server-id：

```linux
# at 552
## 执行时间:17:50:46；pos点:665
#131128 17:50:46 server id 1  end_log_pos 665   Query   thread_id=11    exec_time=0     error_code=0 
SET TIMESTAMP=1385632246/*!*/;
update t_user set name='xyz' where id=1             ## 执行的SQL
/*!*/;
# at 665
#131128 17:50:46 server id 1  end_log_pos 692   Xid = 1454  ## 执行时间:17:50:46；pos点:692 

注：
server id 1     数据库主机的服务号
end_log_pos 665 pos点
thread_id=11    线程号
```

- 其次，MySQL的二进制日志实现还提供了–log-slave-updates选项，如果不打开这个选项，则从库不会将主库同步过来的写操作记录到二进制日志中。默认为关闭的。具体可看官方文档：[log_slave_updates](https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_log_slave_updates)


**架构模式**

- 双主架构的示意图如下：

![Mysql主从](/images/doublemaster.png)

- 在实际应用中，并不是将两个同时用于提供写服务，而是其中一个提供写服务，另外一个提供读服务或者不提供任何服务，只做备份。这样设计的目的是，因为主从复制是异步的，存在延迟，如果两个都提供写服务，则可能会存在对同一个数据进行并发修改时，如主库A先执行，主库B后执行，在主库A同步给主库B之前，主库B已经执行了写操作，故会存在数据不一致问题，即正常情况下为：A写 -> A同步给B -> B重放A的写 -> B执行写，但是并发情况下，可能就是：A写 -> B写 -> A同步给B -> B重放A的写，这样就B的写就会被A的覆盖了。


#### Master-slaves-slaves：级联复制架构

- 级联复制架构主要用于解决主库由于存在太多从库而导致资源消耗过大，主库性能下降的问题，实现方式为：将一部分从库直连主库，另外一部分从库连接这些直连主库的从库的其中一个或多个，从而实现级联复制，如下：

![Mysql主从](/images/masterslaveslave.png)

- 这种架构可以降低主库的负载，但是存在的问题是由于存在了多级复制，而主从复制由于是异步复制存在延迟问题，故最底层的从库会延迟更大，并且延迟随着级联层次的增大而增大，故如果读服务不能容忍太大的数据延迟，则不能采用这种架构模式。


#### Master-Master-slaves：双主多从架构

- 双主多从架构模式是一主多从和双主的结合，由之前的分析可知，在双主架构中不是两个都提供写服务，而是其中一个提供写服务，另外一个提供读服务或者备份。所以可以将该备份主库利用起来，即使从库连接这个备份主库，而不是直连提供写服务的主库，这样可以降低提供写服务主库的压力，如图：

![Mysql主从](/images/doublemsaterslave.png)

- 这种架构模式下：当主库挂了或者需要停机维护，可以将备份主库升级了提供写服务的主库，此时从库无需变动；如果备份主库挂了或者需要停机维护，则可以将从库临时连接提供写服务的主库。

- 其次这种架构模式下由于提供写服务的主库只需复制同步数据给备份主库，备份主库只需将数据复制给从库，故负载都较低，降低了因为负载问题而出现故障的概率，提供了系统整体的稳定性。





