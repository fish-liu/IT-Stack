
本文转载自 ： https://blog.csdn.net/u010013573/article/details/88822108 和 https://blog.csdn.net/u010013573/article/details/89299016

### explain命令详解

- explain命令的使用很简单，主要用于对SELECT语句的执行情况进行分析，示例如下：

```sql
mysql> EXPLAIN SELECT DISTINCT(trade_date) FROM order WHERE user_id=1 ORDER BY trade_date DESC LIMIT 10;
+----+-------------+-------------------+------------+------+----------------------+--------------+---------+-------+------+----------+--------------------------+
| id | select_type | table             | partitions | type | possible_keys        | key          | key_len | ref   | rows | filtered | Extra                    |
+----+-------------+-------------------+------------+------+----------------------+--------------+---------+-------+------+----------+--------------------------+
|  1 | SIMPLE      | order             | NULL       | ref  | PRIMARY,idx_user_trade|idx_user_trade| 768    | const |   20 |   100.00 | Using where; Using index |
+----+-------------+-------------------+------------+------+----------------------+--------------+---------+-------+------+----------+--------------------------+
1 row in set, 1 warning (0.03 sec)
```

- 对应order表的索引情况：

```sql
KEY `idx_user_trade` (`user_id`,`trade_date`) USING BTREE
```

- 1、id：执行的序号，这个语句没有子查询，故只有1，值越大越先执行；

- 2、select_type：数据读取类型，这里只是针对单表，也没有UNION操作，故是SIMPLE，其他类型包括：PRIMARY, UNION RESULT, SUBQUERY等；

- 3、table：查询涉及的表；

- 4、partitions：查询涉及的表的哪些分区；

- 5、type：访问类型，指明了MySQL以何种方式查找表中符合条件的行，这个也是需要重点关注的一项指标，包含的类型为：ALL, index, range, ref, eq_ref, const/system, NULL，性能依次变好，其中：

  - ALL：为全表扫描，性能最差；
  
  - index：为全索引扫描，性能通常也是不够理想；
  
  - range：为对索引进行范围扫描，然后返回对应的数据行，如SQL包含BETWEEN，>=，IN()等语句时就是range；
  
  - ref：为索引查找，返回匹配单个索引值的数据行，如果不是范围查询，则需要至少达到这个级别；
  
  - eq_ref：也是索引查找，不过最多只返回一条记录，通常是在主键或者唯一性索引上，性能较好；
  
  - const/system：为表只有最多一个匹配行，直接读取对应的数据行，不需要查找索引再根据索引的结果读取数据行，通常是主键或唯一性索引上有固定值的情形；
  
  - NULL：在执行阶段不需要访问表，直接从索引返回需要的值。
  
- 6、possible_keys：该次查询可以使用的索引；

- 7、key：该次查询实际使用的索引；

- 8、key_len：使用索引时，所使用的索引值的最大字节数，当type为NULL时，该值也为NULL；

- 9、ref：哪些字段或常量配合key将数据行从表中获取出来；

- 10、rows：估计查找到所需要的行，大概需要扫描读取多少数据行，这个值越小越好；即存储引擎大概需要读取并返回rows的值这么多行数据给server层；通常与下面的filtered一起分析，即如果rows为5，而实际需要的查询结果为1条记录，则filtered的值为大概为1/5；如下：

```sql
mysql> explain SELECT type, expire_date, id FROM test WHERE id='11111' AND type=3 AND price BETWEEN 80 AND 80.999;
+----+-------------+-------------------+------------+------+---------------+-------------+---------+-------------+------+----------+-------------+
| id | select_type | table             | partitions | type | possible_keys | key         | key_len | ref         | rows | filtered | Extra       |
+----+-------------+-------------------+------------+------+---------------+-------------+---------+-------------+------+----------+-------------+
|  1 | SIMPLE      | test			   | NULL       | ref  | idx_ul_type   | idx_id_type | 769     | const,const |    5 |    11.11 | Using where |
+----+-------------+-------------------+------------+------+---------------+-------------+---------+-------------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

SQL执行情况：这条SQL实际返回了一条记录。

```sql
mysql> SELECT type, expire_date, id FROM test WHERE id='11111' AND type=3 AND price BETWEEN 80 AND 80.999;
省略具体内容
1 row in set (0.00 sec)
```

如果把price BETWEEN 80 AND 80.999的条件去掉，则返回5条记录：

```sql
mysql> SELECT type, expire_date, id FROM test WHERE id='11111' AND type=3;
省略具体内容
5 rows in set (0.00 sec)
```

索引情况如下：在id和type的两个列建了一个联合索引，不包含price列，故由于price没有索引，实际存储引擎会读取并返回5条记录给server层，server层在根据 price BETWEEN 80 AND 80.999再过滤最后剩下一条记录。

```sql
KEY `idx_id_type` (`id`,`type`) USING BTREE
```

如果把price加到idx_id_type索引中，即idx_id_type (id,type,price) ，则执行情况如下：

```sql
mysql> explain SELECT type, expire_date, id FROM test WHERE ul='11111' AND type=3 AND price BETWEEN 80 AND 80.999;
+----+-------------+-------------------+------------+-------+---------------+-------------+---------+------+------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys | key         | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+---------------+-------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | test			   | NULL       | range | idx_id_type   | idx_id_type | 778     | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+---------------+-------------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
```

- 11、filtered：此查询条件所过滤的数据的百分比，表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例；越大表示存储引擎返回给server层的都是有用的，故说明效率较高，通常都是100%；

- 12、Extra：此处执行的额外信息，一次SQL查询的Extra可以包含以下的一条或多条，包括：
 
  - Using where：表示SQL语句存在WHERE条件，不是获取全表数据，一般使用了WHERE条件都会有这个；
  
  - Using index：表示使用覆盖索引返回数据，不需要访问表，通常是指该查询性能较好；
  
  - Using index condition：这个是在5.6版本后加入的新特性，主要作用是当WHERE中的某个条件对应的字段，如a，是加了索引的，但是无法使用，如使用了 a like ‘%abc%’ 这种SQL，在没有这个特性之前，存储引擎此时无法使用这个字段对应的索引了，需要回表找到符合WHERE其他条件的数据行，即full row正行数据，然后传给server层，最后在server层处理a like '%abc%'这个条件，即使a这个字段加了索引，这样就存储引擎就需要读取较多的数据行和传给server层较多的数据。拥有这个特性之后，存储引擎层会使用索引来处理a like '%abc%'这个SQL，进一步过滤，从而减少回表查询的次数和传给server层的数据量；详见官方文档：[8.2.1.5 Index Condition Pushdown Optimization](https://dev.mysql.com/doc/refman/5.7/en/index-condition-pushdown-optimization.html)
    ，如下为详细例子：
    
    ![Mysql  index condition](/images/indexcondition.png)
    
    
  - Using temporary：表示使用了临时表来进行分组、排序或者多表join，通常表示查询效率不高，需要优化；
  
  - Using filesort：表示需要使用一个外部文件索引来对结果进行排序，而不是直接根据内部索引顺序从表中读取数据，这个过程通常需要消耗比较大的CPU资源，需要优化。    



### 索引失效的六种场景

#### 一、概述

以下基于用户订单表t_order和订单清单条目表t_order_item来分析，二者通过order_id来建立外键约束。

```sql
mysql> show create table t_order;
+---------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table   | Create Table                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
+---------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| t_order | CREATE TABLE `t_order` (
  `order_id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `cost` double DEFAULT NULL,
  `buy_date` date NOT NULL,
  PRIMARY KEY (`order_id`),
  KEY `idx_order_buy_date` (`order_id`,`buy_date`),
  KEY `idx_user_id` (`user_id`),
  KEY `idx_user_id_buy_date` (`user_id`,`buy_date`),
  CONSTRAINT `user_refrence` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8 |
+---------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> show create table t_order_item;
+--------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table        | Create Table                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
+--------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| t_order_item | CREATE TABLE `t_order_item` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `product_id` int(11) NOT NULL,
  `price` double NOT NULL,
  `num` double NOT NULL,
  `order_id` int(20) NOT NULL,
  `remark` varchar(64) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_remark` (`remark`),
  KEY `idx_num` (`num`),
  KEY `order_reference` (`order_id`),
  CONSTRAINT `order_reference` FOREIGN KEY (`order_id`) REFERENCES `t_order` (`order_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 |
+--------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.01 sec)
```


#### 二. 最左前戳匹配

- 最左前戳匹配主要是innodb存储引擎的B+树索引的特性导致的，即对于联合索引中的多个索引列在WHERE中需要从左到右保持联合索引中的列的顺序出现，如（a,b,c)，则必须为where a=xx and b=xx等，如果是where b=xx and c=xx则无法使用该联合索引，注意如果是where b=xx and a=xx 则还是可以继续使用索引的，最左前戳匹配只是针对使用的列需要保证从左到右，where中的顺序没有限制，如下：t_order表包含联合索引：KEY idx_user_id_buy_date (user_id,buy_date)：前两个SQL均可以使用该索引，最后一个只包含buy_date无法使用。

```sql
mysql> explain select * from t_order where buy_date=curdate() and user_id=1;
+----+-------------+---------+------------+------+----------------------------------+----------------------+---------+-------------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys                    | key                  | key_len | ref         | rows | filtered | Extra |
+----+-------------+---------+------------+------+----------------------------------+----------------------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | t_order | NULL       | ref  | idx_user_id,idx_user_id_buy_date | idx_user_id_buy_date | 7       | const,const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+----------------------------------+----------------------+---------+-------------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from t_order where user_id=1 and buy_date=curdate();
+----+-------------+---------+------------+------+----------------------------------+----------------------+---------+-------------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys                    | key                  | key_len | ref         | rows | filtered | Extra |
+----+-------------+---------+------------+------+----------------------------------+----------------------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | t_order | NULL       | ref  | idx_user_id,idx_user_id_buy_date | idx_user_id_buy_date | 7       | const,const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+----------------------------------+----------------------+---------+-------------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from t_order where buy_date=curdate();
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t_order | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |    25.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

- 对于普通单列索引，如果是字符串则也可以取字符串的前几个字符而不是整个字符串。

- 关于最左前戳匹配可参考：：[Innodb存储引擎索引的实现原理](db/mysql/innodb.md)


#### 三. 字符串使用 like %

- 如果字符串类型的索引列在查询条件中使用了like和通配符%进行模糊查询，跟最左前戳匹配类似，由于索引基于B+Tree实现，故如果%是在最左边则无法使用使用索引，如下：当%位于最左边时无法使用索引，否则可以继续使用索引。

```sql
mysql> explain select * from t_order_item where remark like "%1";
+----+-------------+--------------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table        | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t_order_item | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using where |
+----+-------------+--------------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.01 sec)

mysql> explain select * from t_order_item where remark like "1%";
+----+-------------+--------------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+
| id | select_type | table        | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+--------------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | t_order_item | NULL       | range | idx_remark    | idx_remark | 195     | NULL |    1 |   100.00 | Using index condition |
+----+-------------+--------------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
```


#### 四. 数据类型不匹配，隐式转换

- 数据类型隐式转换是指查询条件中的索引列对应的值的类型和列的类型不一致，需要MySQL进行隐式转换，如列的类型为字符串而查询条件值为数字，如下：在t_order_item表新增一个remark列，类型为varchar，并加上索引，当查询值为数字1时，type显示ALL，未使用索引，故字符串的列记得加双引号保持字符串类型。不过，反过来，即数字类型的字段用了字符串，则索引是可以正常使用的。

```sql
mysql> alter table t_order_item add column remark varchar(64);
Query OK, 0 rows affected (0.10 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> alter table t_order_item add index idx_remark(remark);
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

# 值为字符串，索引正常使用
mysql> explain select * from t_order_item where remark="1";
+----+-------------+--------------+------------+------+---------------+------------+---------+-------+------+----------+-------+
| id | select_type | table        | partitions | type | possible_keys | key        | key_len | ref   | rows | filtered | Extra |
+----+-------------+--------------+------------+------+---------------+------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | t_order_item | NULL       | ref  | idx_remark    | idx_remark | 195     | const |    1 |   100.00 | NULL  |
+----+-------------+--------------+------------+------+---------------+------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

# 值为数字，索引失效
mysql> explain select * from t_order_item where remark=1;
+----+-------------+--------------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table        | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t_order_item | NULL       | ALL  | idx_remark    | NULL | NULL    | NULL |    1 |   100.00 | Using where |
+----+-------------+--------------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 3 warnings (0.01 sec)
```

- 除了字符串之外，日期类型的字段如果使用了字符串，索引也会失效，如下buy_date购买日期，如果使用字符串则失效，如果使用curdate函数获取日期，则正常使用。

```sql
mysql> explain select * from t_order where buy_date = '2019-04-10';
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t_order | NULL       | ALL  | idx_buy_date  | NULL | NULL    | NULL |    4 |   100.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from t_order where buy_date = curdate();
+----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | t_order | NULL       | ref  | idx_buy_date  | idx_buy_date | 3       | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from t_order where buy_date = DATE_ADD(CURDATE(),INTERVAL 1 DAY) ;
+----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | t_order | NULL       | ref  | idx_buy_date  | idx_buy_date | 3       | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```


#### 五. OR条件

- 对应innodb存储引擎来说，如果要获取所有列的数据，即不能使用覆盖索引，则OR两边的列都是不能使用索引的，即使两个列都有索引，或者是同一个列，如下，order_id为主键，buy_date包含有索引：

```sql
mysql> explain select * from t_order where buy_date=date_add(curdate(), interval 1 DAY) or buy_date=curdate();
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t_order | NULL       | ALL  | idx_buy_date  | NULL | NULL    | NULL |    5 |    40.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> 
mysql> explain select * from t_order where user_id=1 or user_id=2;
+----+-------------+---------+------------+------+----------------------------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys                    | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+----------------------------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t_order | NULL       | ALL  | idx_user_id,idx_user_id_buy_date | NULL | NULL    | NULL |    5 |   100.00 | Using where |
+----+-------------+---------+------------+------+----------------------------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

- 但是如果只需要返回某些列，并且这些类可以通过联合索引覆盖到，则可以继续使用索引，如下：t_order表包含了联合索引(user_id, buy_date)。所以如果必须使用OR，则可以考虑使用覆盖索引来避免索引失效。

```sql
mysql> explain select user_id,buy_date from t_order where user_id=1 or user_id=2;
+----+-------------+---------+------------+-------+----------------------------------+----------------------+---------+------+------+----------+--------------------------+
| id | select_type | table   | partitions | type  | possible_keys                    | key                  | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+---------+------------+-------+----------------------------------+----------------------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | t_order | NULL       | index | idx_user_id,idx_user_id_buy_date | idx_user_id_buy_date | 7       | NULL |    5 |   100.00 | Using where; Using index |
+----+-------------+---------+------------+-------+----------------------------------+----------------------+---------+------+------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select user_id, buy_date from t_order where buy_date=date_add(curdate(), interval 1 DAY) or buy_date=curdate();
+----+-------------+---------+------------+-------+---------------+----------------------+---------+------+------+----------+--------------------------+
| id | select_type | table   | partitions | type  | possible_keys | key                  | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+---------+------------+-------+---------------+----------------------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | t_order | NULL       | index | idx_buy_date  | idx_user_id_buy_date | 7       | NULL |    5 |    40.00 | Using where; Using index |
+----+-------------+---------+------------+-------+---------------+----------------------+---------+------+------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)
```

- 如果不适合创建联合索引来解决问题，如当OR查询需要返回的列较多时，则可以通过UNION来替代OR，如下：user_id和buy_date上面均有索引，当通过UNION时，则可以使用到索引，不过由Using temporary可知，需要额外的内存来汇总结果。

```sql
mysql> explain select * from t_order where user_id=2 union select * from t_order where buy_date=curdate();
+----+--------------+------------+------------+------+----------------------------------+--------------+---------+-------+------+----------+-----------------+
| id | select_type  | table      | partitions | type | possible_keys                    | key          | key_len | ref   | rows | filtered | Extra           |
+----+--------------+------------+------------+------+----------------------------------+--------------+---------+-------+------+----------+-----------------+
|  1 | PRIMARY      | t_order    | NULL       | ref  | idx_user_id,idx_user_id_buy_date | idx_user_id  | 4       | const |    1 |   100.00 | NULL            |
|  2 | UNION        | t_order    | NULL       | ref  | idx_buy_date                     | idx_buy_date | 3       | const |    1 |   100.00 | NULL            |
| NULL | UNION RESULT | <union1,2> | NULL       | ALL  | NULL                             | NULL         | NULL    | NULL  | NULL |     NULL | Using temporary |
+----+--------------+------------+------------+------+----------------------------------+--------------+---------+-------+------+----------+-----------------+
3 rows in set, 1 warning (0.00 sec)

mysql> explain select * from t_order where user_id=2 or buy_date=curdate();
+----+-------------+---------+------------+------+-----------------------------------------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys                                 | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+-----------------------------------------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t_order | NULL       | ALL  | idx_user_id,idx_user_id_buy_date,idx_buy_date | NULL | NULL    | NULL |    4 |   100.00 | Using where |
+----+-------------+---------+------------+------+-----------------------------------------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```


#### 六. 列参与了MySQL函数的计算

- 如果SQL查询条件中索引列对应的值是通过函数计算出来而不是某个确定的值，则无法使用索引，其中函数的使用不是说使用了MySQL函数就不可使用索引了，而是索引列参与到函数计算时不能再使用索引，如下：

  - （1）简单加减计算：order_id为t_order表的主键，由type可知使用了全表扫描，正常是PRIMARY使用主键索引的。
  
  ```sql
  mysql> explain select * from t_order where order_id + 1 = 2;
  +----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
  | id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
  +----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
  |  1 | SIMPLE      | t_order | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |   100.00 | Using where |
  +----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
  1 row in set, 1 warning (0.00 sec)
  ```

  - （2）索引列参与到MySQL函数的使用，如下：第一个SQL中索引列buy_date参与到了DATE_ADD函数中，故type显示ALL，全表扫描；第二个SQL只是使用MySQL的函数可以继续使用索引，type显示ref，key为idx_buy_date。
  
  ```sql
  mysql> explain select * from t_order where buy_date = DATE_ADD(buy_date,INTERVAL 1 DAY) ;
  +----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
  | id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
  +----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
  |  1 | SIMPLE      | t_order | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |    25.00 | Using where |
  +----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
  1 row in set, 1 warning (0.01 sec)
  
  mysql> explain select * from t_order where buy_date = DATE_ADD(CURDATE(),INTERVAL 1 DAY) ;
  +----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
  | id | select_type | table   | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra |
  +----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
  |  1 | SIMPLE      | t_order | NULL       | ref  | idx_buy_date  | idx_buy_date | 3       | const |    1 |   100.00 | NULL  |
  +----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
  1 row in set, 1 warning (0.00 sec)
  ```

#### 七. 查询返回的数据超过了表的30%

- 如果查询需要返回的数据超过了表所有的30%，则MySQL优化器会自动放弃使用索引而进行全表扫描，注意如果可以使用覆盖索引而不需要回表查询则MySQL会继续使用索引，如下t_order表只包含5条记录，并且4条属于用户1，1条属于用户2：

```sql
mysql> select * from t_order;
+----------+---------+------+------------+
| order_id | user_id | cost | buy_date   |
+----------+---------+------+------------+
|        1 |       1 |  100 | 2019-04-10 |
|        2 |       1 |  102 | 2019-04-10 |
|        3 |       1 |  103 | 2019-04-10 |
|        4 |       1 |  104 | 2019-04-10 |
|        5 |       2 | 1000 | 2019-04-14 |
+----------+---------+------+------------+
5 rows in set (0.00 sec)
```

- 获取所有数据列：user_id列包含索引，如果查询用户1的order则放弃使用索引，type显示ALL；如果查询用户2的order则继续使用索引，type显示ref：

```sql
mysql> explain select * from t_order where user_id=1;
+----+-------------+---------+------------+------+----------------------------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys                    | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+----------------------------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t_order | NULL       | ALL  | idx_user_id,idx_user_id_buy_date | NULL | NULL    | NULL |    4 |   100.00 | Using where |
+----+-------------+---------+------------+------+----------------------------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from t_order where user_id=2;
+----+-------------+---------+------------+------+----------------------------------+-------------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys                    | key         | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+----------------------------------+-------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | t_order | NULL       | ref  | idx_user_id,idx_user_id_buy_date | idx_user_id | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+----------------------------------+-------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

- 同样是查询用户1的所有订单，如果只需要返回user_id和购买日期buy_date，由于存在联合索引idx_user_id_buy_date，故可以进行索引覆盖，extra显示Using index，故使用该联合索引：

```sql
mysql> explain select user_id,buy_date from t_order where user_id=1;
+----+-------------+---------+------------+------+----------------------------------+----------------------+---------+-------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys                    | key                  | key_len | ref   | rows | filtered | Extra       |
+----+-------------+---------+------------+------+----------------------------------+----------------------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | t_order | NULL       | ref  | idx_user_id,idx_user_id_buy_date | idx_user_id_buy_date | 4       | const |    4 |   100.00 | Using index |
+----+-------------+---------+------------+------+----------------------------------+----------------------+---------+-------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```


### 小表驱动大表

参加：https://blog.csdn.net/u010013573/article/details/89199397

- 在关联操作中，主表和关联表的顺序对性能影响很重要，特别对于JOIN/INNER JOIN这种匹配关联来说，因为LEFT/RIGHT JOIN一般是固定的不能调整顺序，而INNER JOIN由于是完全匹配，故主表和关联表的顺序可以调换。

- 一般的优化规则是：小表驱动大表，即数据行较少的表在左边，数据行较多的表在右边。

- 小表驱动大表的原理：在join当中，是使用左边表的每一个数据行去扫描右边的整个表的所有数据行，所以虽然总的匹配次数是相同的，但是如果左边表数据行很多，则需要加载右边的整个表很多次，使用小表驱动大表主要是要减少这个次数，即内循环次数，来提高性能。

- 小表驱动大表的设计只是我们编写SQL需要注意的，但是MySQL优化器不一定就完全按照这个顺序，MySQL是使用“小结果集”驱动“大结果集”的，即如果SQL语句还包含其他WHERE查询条件，排序ORDER BY等，则以上顺序可能还是反过来的，如果要强制该顺序，则可以使用STRAIGHT JOIN来替代INNER JOIN。具体可以参考这位博主的文章：[MySQL优化的奇技淫巧之STRAIGHT_JOIN](https://blog.huoding.com/2013/06/04/261)
