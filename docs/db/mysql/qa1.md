
### 存储引擎相关

#### 存储引擎的概念

- 存储引擎的概念是MySQL里面才有的，不是所有的关系型数据库都有存储引擎这个概念；

- 在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型(即：对表的存储、操作等的实现方法不同)；

- 不同的存储引擎决定了MySQL数据库中的表可以用不同的方式来存储。

- 表是什么，表本质上就是磁盘上的文件。


#### 存储引擎的分类

> 在MySQL中的存储引擎有很多种，可以通过“SHOW ENGINES”语句来查看。
> Mysql的默认存储引擎： MySQL5.5之前，默认的存储引擎是MyISAM ；MySQL5.5之后的默认存储引擎。
> 大部分转载自：https://blog.csdn.net/yjclsx/java/article/details/81911027

**MyISAM存储引擎**

MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。它是MySQL5.5之前的默认存储引擎。

- 使用场景：如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。

- MyISAM主要特性有：

  0、不支持事务，不支持行锁，不支持外键
  
  1、myisam存储引擎使用的是表锁
  
  2、占用空间小，处理速度快（拥有较高的插入、查询速度）

  3、支持大文件

  4、BLOB和TEXT列可以被索引，支持FULLTEXT类型的索引，而InnoDB不支持这种类型的索引

  3、NULL被允许在索引的列中，这个值占每个键的0~1个字节

  4、每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。

  5、可以把数据文件和索引文件放在不同目录

  6、每个字符列可以有不同的字符集

- 存储格式：

  1、静态表（默认）：字段都是非变长的（每个记录都是固定长度的）。存储非常迅速、容易缓存，出现故障容易恢复；占用空间通常比动态表多。
     
     静态表的数据在存储的时候会按照列的宽度定义补足空格，在返回数据给应用之前去掉这些空格。如果需要保存的内容后面本来就有空格，在返回结果的时候也会被去掉。（其实是数据类型char的行为，动态表中若有这个数据类型也同样会有这个问题）
    
  2、动态表：占用的空间相对较少，但是频繁的更新删除记录会产生碎片，需要定期执行optimize table或myisamchk -r命令来改善性能，而且出现故障的时候恢复比较困难。

  3、压缩表：使用myisampack工具创建，占用非常小的磁盘空间。因为每个记录是被单独压缩的

- 存储文件

  使用MyISAM引擎创建数据库，将产生3个文件。文件的名字以表名字开始，扩展名之处文件类型：frm文件存储表定义、数据文件的扩展名为.MYD（MYData）、索引文件的扩展名时.MYI（MYIndex）。  


**InnoDB存储引擎**

InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL5.5之后的默认存储引擎。

- 场景：如果应用对事务的完整性有较高的要求，在并发条件下要求数据的一致性，数据操作中包含读、插入、删除、更新，那InnoDB是最好的选择。在计费系统、财务系统等对数据的准确性要求较高的系统中被广泛应用。
  
- InnoDB主要特性有：

  1、支持事务，支持行级锁,支持外键约束，崩溃修复能力和并发控制

  2、索引和数据存储在同一个文件中
  
  3、AUTO_INCREMENT
  
  4、读写效率较差，占用的数据空间相对较大（占用更多的磁盘空间来存储数据和索引）

- 存储格式 ：

  InnoDB存储数据和索引有共享表空间存储和独占表空间存储两种方式，通过参数innodb_file_per_table控制，0表示共享空间，也是默认的，1表示独占空间
  
  1、两种方式的表结构（描述）都保存在.frm文件中
  
  2、共享表空间：
  
  每一个数据库的所有表的数据、索引都保存在一个文件中，默认在data目录下，名为ibdata1，大小为10M的文件，可以通过参数innodn_data_file_path=/data/ibdata1:2000M来指定存储路径。
  
  优点：
  
  （1）、可以将表空间分为多个文件放在不同的磁盘上，分布IO，提高性能。innodn_data_file_path=/data/ibdata1:2000M；/db/ibdata2:2000M:autoextend  ；
   其中 autoextend表示如果指定的2000M空间用满后，该文件自动增长。也就是说采用共享空间存储，存储空间的大小不受文件系统下文件大小的限制了，而取决于自身的限制，官方文档显示，表空间的最大限制是64TB。
  
  （2）、表数据和表结构放在一起，方便管理
  
  缺点：由于所有的数据和索引都是在一个文件中混合存储，这样的话对一个表做了大量的删除操作后，表空间中会产生大量的空隙
  
  3、独占表空间存储：
  
  每一张表都有自己独立的表空间，表的结构依然在.frm文件中，还有一个后缀为.ibd的文件，保存了这张表的数据和索引。
  
  优点：每张表都有自己独立的表空间，可实现单表在不同数据库中移动空间可回收。drop table会自动回收；删除数据后，通过alter table emp engine=innodb也可回收不用的表空间
  效率和性能会好一些
  
  缺点：由于每个表的数据都是以一个单独的文件来存放，所以会受到文件系统的大小限制
  

**MEMORY存储引擎**

MEMORY存储引擎将表中的数据存储到内存中，每个memory表对应一个磁盘文件。格式是.frm.

- 由于他的数据是存放在内存中的，并且默认使用HASH索引，所以它的访问速度特别快,同时也造成了他的缺点，就是数据库服务一旦关闭，数据就会丢失，另外对表的大小有限制

- MEMORY存储引擎默认使用哈希（HASH）索引，其速度比使用B-+Tree型要快，但也可以使用B树型索引。由于这种存储引擎所存储的数据保存在内存中，所以其保存的数据具有不稳定性，比如如果mysqld进程发生异常、重启或计算机关机等等都会造成这些数据的消失，所以这种存储引擎中的表的生命周期很短，一般只使用一次。现在mongodb、redis等NOSQL数据库愈发流行，MEMORY存储引擎的使用场景越来越少。

- 场景：如果需要该数据库中一个用于查询的临时表。


**MERGE存储引擎**

- MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同，尽管其使用不如其它引擎突出，但是在某些情况下非常有用。说白了，Merge表就是几个相同MyISAM表的聚合器；Merge表中并没有数据，对Merge类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行操作。

- 场景：对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间端相关。例如：可以用12个相同的表来存储服务器日志数据，每个表用对应各个月份的名字来命名。当有必要基于所有12个日志表的数据来生成报表，这意味着需要编写并更新多表查询，以反映这些表中的信息。与其编写这些可能出现错误的查询，不如将这些表合并起来使用一条查询，之后再删除Merge表，而不影响原来的数据，删除Merge表只是删除Merge表的定义，对内部的表没有任何影响。


**ARCHIVE存储引擎**

- Archive是归档的意思，在归档之后很多的高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。在MySQL 5.5版以前，Archive是不支持索引，但是在MySQL 5.5以后的版本中就开始支持索引了。Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。

- 场景：由于高压缩和快速插入的特点Archive非常适合作为日志表的存储引擎，但是前提是不经常对该表进行查询操作。


#### 存储引擎的选择

![存储引擎](/images/engines.png)


#### 存储引擎的使用

1、创建表时指定引擎
```sql
create table innodb_t2(id int)engine=innodb;
```

2、在配置文件中指定默认的存储引擎
```sql
linux:vim /etc/my.cnf   windows:my.ini文件
[mysqld]
default-storage-engine=INNODB  #配置默认引擎，现在用的mysql默认基本都是InnoDB，所以其实都可以不用配置了
innodb_file_per_table=1  #表示独立表空间存储，可以不写
```


**问题： MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别？**

**问题： InnoDB与MyISAM的区别，在事务、锁级别，各自的适用场景？**

**问题： MySQL InnoDB存储的文件结构**


----------------

### 事务相关

1.事务ACID

* 原子性（atomicity）一个事务必须被视为一个不可分割的最小工作单元，整个事务中所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作

* 一致性（consistency）数据库总是从一个一致性的状态转换到另外一个一致性的状态

* 隔离性（isolation）一个事务所做的修改在最终提交以前，对其他事务是不可见的

* 持久性（durability）一旦事务提交，则其所做的修改就会永久保存到数据库中

2.四种隔离级别

* READ UNCOMMITTED（未提交读），事务中的修改，即使没有提交，对其他事务也都是可见的，事务可以读取未提交的数据，也被称为脏读（Dirty Read），这个级别会导致很多问题

* READ COMMITTED（提交读），大多数数据库系统的默认隔离级别，一个事务开始时，只能“看见”已经提交的事务所做的修改，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的，也叫不可重复读（nonrepeatable read），有可能出现幻读（Phantom Read），指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）

* REPEATABLE READ（可重复读），通过InnoDB和XtraDB存储引擎，是MySQL的默认事务隔离级别

* SERIALIZABLE（可串行化）最高级别，通过强制事务串行执行，避免了幻读问题，会在读取的每一行数据上都加锁，可能导致大量的超时和锁争用的问题

<!--
3.事务日志：

存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘，称为预写式日志（Write-Ahead Logging）
-->


**问题： 事务四大特性（ACID）原子性、一致性、隔离性、持久性？**

- 原子性：事务是一个不可分割的整体，所有操作要么全做，要么全不做；只要事务中有一个操作出错，回滚到事务开始前的状态的话，那么之前已经执行的所有操作都是无效的，都应该回滚到开始前的状态。

- 一致性：事务执行前后，数据从一个状态到另一个状态必须是一致的

- 隔离性：多个并发事务之间相互隔离，不能互相干扰。

- 持久性：事务完成后，对数据库的更改是永久保存的，不能回滚。

**问题： 事务隔离级别有哪些?MySQL的默认隔离级别是?**

隔离级别：READ UNCOMMITTED 未提交读、 READ COMMITTED 提交读、REPEATABLE READ 可重复读、 SERIALIZABLE 可串行化

mysql的默认隔离级别是 REPEATABLE READ 可重复读
 
**问题： 事务的隔离级别和原理**

隔离级别：READ UNCOMMITTED 未提交读、 READ COMMITTED 提交读、REPEATABLE READ 可重复读、 SERIALIZABLE 可串行化

在 RU 隔离级别下，直接读取版本的最新记录就 OK，对于 SERIALIZABLE 隔离级别，则是通过加锁互斥来访问数据，而RC 和RR隔离级别下主要是通过锁和MVCC机制来实现。

mvcc（多版本并发控制） 要点：

1、SELECT 操作不加锁而是通过 MVCC 机制读取指定的版本历史记录，并保证读取的记录值符合事务所处的隔离级别，解决并发场景下的读写冲突

2、原理：每一行记录都有两个隐藏列： DATA_TRX_ID（记录最近更新这条记录的事务ID） 、 DATA_ROLL_PTR（记录undo log 中的指针） 

3、多个事务并行操作某行数据的情况下，不同事务对该行数据的 UPDATE 会产生多个版本，组成一个版本链

4、有个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务，叫做read view；通过这个列表（readview）来判断记录的某个版本是否对当前事务可见。


**问题： 高并发下如何做到安全的修改同一行数据，乐观锁和悲观锁是什么，INNODB的行级锁有哪2种，解释其含义**

**悲观锁：**

- 悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能对数据进行操作。

- 悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。

- 共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。

- 共享锁： 对于多个不同的事务，对同一个资源共享同一个锁。在执行语句后面加上lock in share mode就代表对某些资源加上共享锁  SELECT * from city where id = "1"  lock in share mode;

- 排他锁： 同一个资源只能有一把锁。在需要执行的语句后面加上for update就可以了

**乐观锁：**

- 乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行提交更新的时候，再去判断是否有冲突。

- 乐观锁不是数据库自带的，需要我们自己去实现 

- 使用版本号：使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式 （添加一列版本号，每次操作都更新这个版本号的值）

- Innodb 的 MVCC 机制就是乐观锁的一种（基于版本控制） 

**Innodb的行级锁：**

- Record Key  Lock ： 单个数据行的锁（锁一行）

- Gap Lock ： 间隙锁，锁住一个范围，但是不包含数据行本身；

- Next Key Lock  ：Record-Key Lock + Gap Lock，锁住数据行本身和一个范围的数据行。

- Innodb 并不是对所有的写事务都使用行锁，使用行锁的前提是：写事务对数据表的写操作的查找条件需要包含索引列，包含主键索引或者辅助索引，如UPDATE … SET … WHERE …中的WHERE列需要包含索引列，否则会使用表锁。
  所以innodb的行锁 锁住的其实是数据行的索引，如果是主键索引，由于主键索引是聚簇索引，故锁住的是数据行本身；如果是辅助索引，锁住的是该索引，而不是具体的数据行。

- 如果普通索引 的 “值重复率”低时，甚至接近主键或者唯一索引的效果，“普通索引”依然是行锁，当“值重复率”高时，MySQL 不会把这个“普通索引”当做索引，即造成了一个没有索引的 SQL，此时引发表锁。


**问题： 数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁**

会出现死锁，两个或多个事务在执行过程中，相互竞争资源而导致相互等待，导致都无法继续执行下去产生死锁的现象。

死锁demo ：https://blog.csdn.net/weixin_33720452/article/details/92386391

死锁的解决： 阻塞回滚，超时回滚，主动检测回滚（Innodb使用了一个等待图算法来检测发生死锁的事务，如果发现某些事务存在等待环，则回滚这些事务中undo日志量最小的事务来解决死锁）

也可参考：https://blog.csdn.net/riemann_/article/details/91349331


**问题： 事务的并发？事务隔离级别，每个级别会引发什么问题**

四个隔离级别：读未提交（read uncommit）、 读提交（read commit） 、 可重复读（repeatable read）、串行化（SERIALIZABLE）

读未提交出现的问题： 脏读（在一个事务内读到了其他事务未提交的数据）

读提交出现的问题：幻读（在一个事务内，两次读取到的数据不一样，如其他事务进行数据插入或者数据删除操作）

可重复度出现的问题：解决了 脏读，幻读，不可重复读，相对于SERIALIZABLE串行化，数据一致性方面唯一的不足是基于MVCC机制读取的数据的快照版本，故数据可能存在延迟。

串行化 ：解决了 脏读，幻读，不可重复读；对读写操作均需要加锁，读操作加共享锁，写操作加互斥锁，串行化了多个事务操作，并发性能最差，数据一致性最好。


**问题： 有哪些锁（乐观锁悲观锁），select 时怎么加排它锁？**

悲观锁：共享说，排他锁

乐观锁：MVCC ， 使用版本号控制 
 
select 时加排它锁： 在需要执行的语句后面加上for update就可以了

---------

### 索引相关

常见的索引有 ： 哈希索引，B-Tree索引，B+Tree索引，空间数据索引（R-Tree）MyISAM表支持空间索引，可以用作地理数据存储；

**哈希索引（hash index）**

基于哈希表实现，只有精确匹配索引所有列的查询才有效，只有Memory引擎显式支持哈希索引
  
 * 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行
 
 * 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序
 
 * 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的
 
 * 只支持等值比较查询，不支持任何范围查询
 
 * 访问哈希索引的数据非常快，除非有很多哈希冲突
 
 * 如果哈希冲突很多的话，一些索引维护操作的代价也会很高
 
 
**B-Tree索引**

* 如果不是按照索引的最左列开始查找，则无法使用索引

* 不能跳过索引中的列

* 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找

  
**问题： 常见的索引** 

**问题： mysql索引为什么使用B+树**

B树和B+树都是多路平衡搜索树，通过在每个节点存放更多的关键字和通过旋转、分裂操作来保持树的平衡来降低树的高度，从而减少数据检索的磁盘访问量
B+树相对于B树的一个主要的不同点是B+的叶子节点通过指针前后相连，具体为通过双向链表来前后相连，所以非常适合执行范围查找。

**问题： MySQL B+Tree索引和Hash索引的区别？**
  

**问题： 索引树是如何维护的?**

**问题： 索引失效场景**

**问题： 索引存储结构、索引搜索原理**

存储结构 ：B+Tree ，搜索原理：B树

**问题： MySQL的几种优化**

**问题： 使用explain优化sql和索引？**

**问题： MySQL慢查询怎么解决？**

1、应用程序是否在检索大量数据

2、MySQL是否在扫描额外的记录

在索引中使用WHERE条件来过滤不匹配的记录；使用索引覆盖扫描（Extra中出现Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中结果；从数据表中返回数据，然后过滤不满足条件的记录（Extra中出现Using Where）

3、重构查询sql 

连接查询（小表驱动大表的规则），子查询改成表连接 ，or 操作优化等  


**问题： 聚集索引和非聚集索引区别？**

**问题： 什么是覆盖索引？**

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，就称为覆盖索引

**问题： 什么是最左前缀原则？**



**问题： 索引是怎么提高查询速度的？**

**问题： MySQL索引是什么样的数据结构？**

**问题： MyISAM与InnoDB实现BTree索引的方式不同在哪？**


### 分库分表

**问题： 分库分表之后,id 主键如何处理？**

**问题： 列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询的问题。**

**问题： Mysql主从复制原理，mysql中如何做故障转移（容灾）**


### 其他奇葩问题

**问题： 数据库自增主键可能的问题**    

参考点: 

- 单表的情况下数据库自增id并没有什么问题；对于MySQL来说，使用自增还是比较划算的，因为索引使用的底层数据结构(B+树)的原因，如果是自增ID的话，那么数据插入时最多就是引起节点的分裂，而如果是使用非自增ID，则有可能会导致节点移动和分裂。

- 并发插入的量比较大的时候，MySQL 中如果有自增字段的话，MySQL 会维护一个自增锁，InnoDB 表引擎会在内存里保存一个计数器来记录 AUTO_INCREMENT 值。当插入一个新行数据时，就会用一个表锁来锁住这个计数器，直到插入结束。如果是一行一行的插入是没有问题的，但是在高并发情况下，表锁会引起 SQL 阻塞，极大的影响性能，还可能会达到 max_connections 值。

- 不同数据库语法和实现不同，数据库迁移的时候或多数据库版本支持的时候需要处理。

- 在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险。

- 如果遇见多个系统需要合并或者涉及到数据迁移会相当痛苦。

- 分表分库的时候会有麻烦（重复id）

优化方案： 

- 对于分库分表的场景，可以采用雪花算法

- 针对主库单点，如果有多个Master库，则每个Master库设置的起始数字不一样，步长一样，可以是Master的个数。比如：Master1 生成的是 1，4，7，10，Master2生成的是2,5,8,11 Master3生成的是 3,6,9,12。这样就可以有效生成集群中的唯一ID，也可以大大降低ID生成数据库操作的负载。

- 使用一个库专门生成id 

- 使用Redis分批次生成id

- UUID

  优点：能够保证独立性，程序可以在不同的数据库间迁移，效果不受影响。保证生成的ID不仅是表独立的，而且是库独立的，这点在你想切分数据库的时候尤为重要。
  
  缺点：比较占地方，和INT类型相比，存储一个UUID要花费更多的空间。使用UUID后，URL显得冗长，不够友好。没有内置的函数获取最新产生的UUID主键。很难记忆。Join操作性能比int要低。UUID做主键将会添加到表上的其他索引中，因此会降低性能。


**问题： 简单说一说drop、delete与truncate的区别**

- drop 直接删掉表（结构和数据） ，将表所占用的空间全释放掉。

- truncate 删除表中所有的数据，删除操作不记录日志；再插入时自增长id又从1开始 。不能加where条件。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小

- delete 删除表中数据，可以加where字句。删除操作记录日志；DELETE操作不会减少表或索引所占用的空间。DELETE的速度没有truncate快（需要记录日志的原因）

- 一般而言，drop > truncate > delete


**问题： varchar和char的使用场景？**

- varchar ：
  
  - 长度是可变的，最多能存放 65532 个字符 ，存取速度没有char快（空间换时间）
  
  - 使用最小的符合需求的长度
  
  - 适合的场景：1、字符串的最大长度比平均长度大很多  2、字符串列很少被更新  3、使用了多字节字符集存储字符串

- char ：

 
  - 长度是不可变的，最多能存放的字符个数 255 ，存取速度快（空间换时间）
  
  - 字符串存储在char类型的列中会删除末尾的空格
  
  - 适合的场景：1、适合存储长度近似的值  2、适合存储短字符串  3、适合存储经常更新的字符串列

**问题： 数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）？**

https://www.cnblogs.com/DiDiao-Liang/articles/8330870.html

https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html


**问题： MySQL 死锁发生的原因和解决**

- 原因：两个或多个事务在执行过程中，相互竞争资源而导致相互等待，导致都无法继续执行下去产生死锁的现象。

- 死锁的解决方法包含：阻塞回滚，超时回滚和主动检测回滚三种解决方法

  主动检测回滚：innodb使用了一个等待图算法来检测发生死锁的事务，如果发现某些事务存在等待环，则回滚这些事务中undo日志量最小的事务来解决死锁，


**问题： MySQL 分别建立索引 a,b,c ，语句 select ...where b=x,c=x,a=x 能不能用到索引，建立联合索引能不能用到，a=x,b>x，能不能用到，用到几个索引？**

**问题： 大表如何优化？**

**问题： 面试官：谈谈你对Mysql的MVCC的理解？**

mvcc（多版本并发控制） 要点：

1、SELECT 操作不加锁而是通过 MVCC 机制读取指定的版本历史记录，并保证读取的记录值符合事务所处的隔离级别，解决并发场景下的读写冲突

2、原理：每一行记录都有两个隐藏列： DATA_TRX_ID（记录最近更新这条记录的事务ID） 、 DATA_ROLL_PTR（记录undo log 中的指针） 

3、多个事务并行操作某行数据的情况下，不同事务对该行数据的 UPDATE 会产生多个版本，组成一个版本链

4、有个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务，叫做read view；通过这个列表（readview）来判断记录的某个版本是否对当前事务可见。

https://baijiahao.baidu.com/s?id=1629409989970483292&wfr=spider&for=pc


**问题：MySQL面试题：主从复制binlog延迟太多怎么办**

参考：https://blog.csdn.net/u010013573/article/details/88372909

主要技术点：

- 硬件资源瓶颈

  1、MySQL主从复制的过程其实就是二进制日志读取，传输，接收，解析执行的过程，故整个过程涉及到的主要资源包括：CPU，内存，磁盘IO，网络IO。

  2、主库的磁盘IO，内存，网络IO ；从库的磁盘IO，内存，网络IO。

- binlog日志量太大

  1、数据库是否以写操作为主，导致binlog日志很大
  
  2、分库分表，将写操作分散到各个数据库，各个数据库的复制流量相对较小，从而通过分而治之的方法来降低整体的延迟。


**问题：加快ALTER TABLE操作的速度**

1.两种方式：

* 一是在一台不提供服务的机器上执行ALTER TABLE操作，然后和提供服务的主库进行切换

* 二是通过“影子拷贝”，创建一张新表，然后通过重命名和删表操作交换两张表及里面的数据















