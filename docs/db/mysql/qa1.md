
### 存储引擎相关

#### 存储引擎的概念

- 存储引擎的概念是MySQL里面才有的，不是所有的关系型数据库都有存储引擎这个概念；

- 在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型(即：对表的存储、操作等的实现方法不同)；

- 不同的存储引擎决定了MySQL数据库中的表可以用不同的方式来存储。

- 表是什么，表本质上就是磁盘上的文件。


#### 存储引擎的分类

> 在MySQL中的存储引擎有很多种，可以通过“SHOW ENGINES”语句来查看。
> Mysql的默认存储引擎： MySQL5.5之前，默认的存储引擎是MyISAM ；MySQL5.5之后的默认存储引擎。
> 大部分转载自：https://blog.csdn.net/yjclsx/java/article/details/81911027

**MyISAM存储引擎**

MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。它是MySQL5.5之前的默认存储引擎。

- 使用场景：如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。

- MyISAM主要特性有：

  0、不支持事务，不支持行锁，不支持外键
  
  1、myisam存储引擎使用的是表锁
  
  2、占用空间小，处理速度快（拥有较高的插入、查询速度）

  3、支持大文件

  4、BLOB和TEXT列可以被索引，支持FULLTEXT类型的索引，而InnoDB不支持这种类型的索引

  3、NULL被允许在索引的列中，这个值占每个键的0~1个字节

  4、每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。

  5、可以把数据文件和索引文件放在不同目录

  6、每个字符列可以有不同的字符集

- 存储格式：

  1、静态表（默认）：字段都是非变长的（每个记录都是固定长度的）。存储非常迅速、容易缓存，出现故障容易恢复；占用空间通常比动态表多。
     
     静态表的数据在存储的时候会按照列的宽度定义补足空格，在返回数据给应用之前去掉这些空格。如果需要保存的内容后面本来就有空格，在返回结果的时候也会被去掉。（其实是数据类型char的行为，动态表中若有这个数据类型也同样会有这个问题）
    
  2、动态表：占用的空间相对较少，但是频繁的更新删除记录会产生碎片，需要定期执行optimize table或myisamchk -r命令来改善性能，而且出现故障的时候恢复比较困难。

  3、压缩表：使用myisampack工具创建，占用非常小的磁盘空间。因为每个记录是被单独压缩的

- 存储文件

  使用MyISAM引擎创建数据库，将产生3个文件。文件的名字以表名字开始，扩展名之处文件类型：frm文件存储表定义、数据文件的扩展名为.MYD（MYData）、索引文件的扩展名时.MYI（MYIndex）。  


**InnoDB存储引擎**

InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL5.5之后的默认存储引擎。

- 场景：如果应用对事务的完整性有较高的要求，在并发条件下要求数据的一致性，数据操作中包含读、插入、删除、更新，那InnoDB是最好的选择。在计费系统、财务系统等对数据的准确性要求较高的系统中被广泛应用。
  
- InnoDB主要特性有：

  1、支持事务，支持行级锁,支持外键约束，崩溃修复能力和并发控制

  2、索引和数据存储在同一个文件中
  
  3、AUTO_INCREMENT
  
  4、读写效率较差，占用的数据空间相对较大（占用更多的磁盘空间来存储数据和索引）

- 存储格式 ：

  InnoDB存储数据和索引有共享表空间存储和独占表空间存储两种方式，通过参数innodb_file_per_table控制，0表示共享空间，也是默认的，1表示独占空间
  
  1、两种方式的表结构（描述）都保存在.frm文件中
  
  2、共享表空间：
  
  每一个数据库的所有表的数据、索引都保存在一个文件中，默认在data目录下，名为ibdata1，大小为10M的文件，可以通过参数innodn_data_file_path=/data/ibdata1:2000M来指定存储路径。
  
  优点：
  
  （1）、可以将表空间分为多个文件放在不同的磁盘上，分布IO，提高性能。innodn_data_file_path=/data/ibdata1:2000M；/db/ibdata2:2000M:autoextend  ；
   其中 autoextend表示如果指定的2000M空间用满后，该文件自动增长。也就是说采用共享空间存储，存储空间的大小不受文件系统下文件大小的限制了，而取决于自身的限制，官方文档显示，表空间的最大限制是64TB。
  
  （2）、表数据和表结构放在一起，方便管理
  
  缺点：由于所有的数据和索引都是在一个文件中混合存储，这样的话对一个表做了大量的删除操作后，表空间中会产生大量的空隙
  
  3、独占表空间存储：
  
  每一张表都有自己独立的表空间，表的结构依然在.frm文件中，还有一个后缀为.ibd的文件，保存了这张表的数据和索引。
  
  优点：每张表都有自己独立的表空间，可实现单表在不同数据库中移动空间可回收。drop table会自动回收；删除数据后，通过alter table emp engine=innodb也可回收不用的表空间
  效率和性能会好一些
  
  缺点：由于每个表的数据都是以一个单独的文件来存放，所以会受到文件系统的大小限制
  

**MEMORY存储引擎**

MEMORY存储引擎将表中的数据存储到内存中，每个memory表对应一个磁盘文件。格式是.frm.

- 由于他的数据是存放在内存中的，并且默认使用HASH索引，所以它的访问速度特别快,同时也造成了他的缺点，就是数据库服务一旦关闭，数据就会丢失，另外对表的大小有限制

- MEMORY存储引擎默认使用哈希（HASH）索引，其速度比使用B-+Tree型要快，但也可以使用B树型索引。由于这种存储引擎所存储的数据保存在内存中，所以其保存的数据具有不稳定性，比如如果mysqld进程发生异常、重启或计算机关机等等都会造成这些数据的消失，所以这种存储引擎中的表的生命周期很短，一般只使用一次。现在mongodb、redis等NOSQL数据库愈发流行，MEMORY存储引擎的使用场景越来越少。

- 场景：如果需要该数据库中一个用于查询的临时表。


**MERGE存储引擎**

- MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同，尽管其使用不如其它引擎突出，但是在某些情况下非常有用。说白了，Merge表就是几个相同MyISAM表的聚合器；Merge表中并没有数据，对Merge类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行操作。

- 场景：对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间端相关。例如：可以用12个相同的表来存储服务器日志数据，每个表用对应各个月份的名字来命名。当有必要基于所有12个日志表的数据来生成报表，这意味着需要编写并更新多表查询，以反映这些表中的信息。与其编写这些可能出现错误的查询，不如将这些表合并起来使用一条查询，之后再删除Merge表，而不影响原来的数据，删除Merge表只是删除Merge表的定义，对内部的表没有任何影响。


**ARCHIVE存储引擎**

- Archive是归档的意思，在归档之后很多的高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。在MySQL 5.5版以前，Archive是不支持索引，但是在MySQL 5.5以后的版本中就开始支持索引了。Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。

- 场景：由于高压缩和快速插入的特点Archive非常适合作为日志表的存储引擎，但是前提是不经常对该表进行查询操作。


#### 存储引擎的选择

![存储引擎](/images/engines.png)


#### 存储引擎的使用

1、创建表时指定引擎
```sql
create table innodb_t2(id int)engine=innodb;
```

2、在配置文件中指定默认的存储引擎
```sql
linux:vim /etc/my.cnf   windows:my.ini文件
[mysqld]
default-storage-engine=INNODB  #配置默认引擎，现在用的mysql默认基本都是InnoDB，所以其实都可以不用配置了
innodb_file_per_table=1  #表示独立表空间存储，可以不写
```


**问题： MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别？**

**问题： InnoDB与MyISAM的区别，在事务、锁级别，各自的适用场景？**

**问题： MySQL InnoDB存储的文件结构**

----------------

### 事务相关

1.事务ACID

* 原子性（atomicity）一个事务必须被视为一个不可分割的最小工作单元，整个事务中所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作

* 一致性（consistency）数据库总是从一个一致性的状态转换到另外一个一致性的状态

* 隔离性（isolation）一个事务所做的修改在最终提交以前，对其他事务是不可见的

* 持久性（durability）一旦事务提交，则其所做的修改就会永久保存到数据库中

2.四种隔离级别

* READ UNCOMMITTED（未提交读），事务中的修改，即使没有提交，对其他事务也都是可见的，事务可以读取未提交的数据，也被称为脏读（Dirty Read），这个级别会导致很多问题

* READ COMMITTED（提交读），大多数数据库系统的默认隔离级别，一个事务开始时，只能“看见”已经提交的事务所做的修改，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的，也叫不可重复读（nonrepeatable read），有可能出现幻读（Phantom Read），指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）

* REPEATABLE READ（可重复读），通过InnoDB和XtraDB存储引擎，是MySQL的默认事务隔离级别

* SERIALIZABLE（可串行化）最高级别，通过强制事务串行执行，避免了幻读问题，会在读取的每一行数据上都加锁，可能导致大量的超时和锁争用的问题

3.事务日志：

存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘，称为预写式日志（Write-Ahead Logging）



**问题： 事务四大特性（ACID）原子性、一致性、隔离性、持久性？**

**问题： 事务隔离级别有哪些?MySQL的默认隔离级别是?**

**问题： 事务的隔离级别和原理**

**问题： 高并发下如何做到安全的修改同一行数据，乐观锁和悲观锁是什么，INNODB的行级锁有哪2种，解释其含义**

**问题： 数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁**

**问题： 事务的并发？事务隔离级别，每个级别会引发什么问题**

**问题： 有哪些锁（乐观锁悲观锁），select 时怎么加排它锁？**


---------
### 索引相关

常见的索引有 ： 哈希索引，B-Tree索引，B+Tree索引，空间数据索引（R-Tree）MyISAM表支持空间索引，可以用作地理数据存储；

**哈希索引（hash index）**

基于哈希表实现，只有精确匹配索引所有列的查询才有效，只有Memory引擎显式支持哈希索引
  
 * 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行
 
 * 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序
 
 * 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的
 
 * 只支持等值比较查询，不支持任何范围查询
 
 * 访问哈希索引的数据非常快，除非有很多哈希冲突
 
 * 如果哈希冲突很多的话，一些索引维护操作的代价也会很高
 
 
**B-Tree索引**

* 如果不是按照索引的最左列开始查找，则无法使用索引

* 不能跳过索引中的列

* 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找


 
  
**问题： 常见的索引** 

**问题： mysql索引为什么使用B+树**

**问题： MySQL B+Tree索引和Hash索引的区别？**
  

**问题： 索引树是如何维护的?**

**问题： 索引失效场景**

**问题： 索引存储结构、索引搜索原理**



**问题： MySQL的几种优化**

**问题： 使用explain优化sql和索引？**

**问题： MySQL慢查询怎么解决？**

1、应用程序是否在检索大量数据

2、MySQL是否在扫描额外的记录

在索引中使用WHERE条件来过滤不匹配的记录；使用索引覆盖扫描（Extra中出现Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中结果；从数据表中返回数据，然后过滤不满足条件的记录（Extra中出现Using Where）

3、重构查询sql 

连接查询（小表驱动大表的规则），子查询改成表连接 ，or 操作优化等  


**问题： 聚集索引和非聚集索引区别？**

**问题： 什么是覆盖索引？**

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，就称为覆盖索引

**问题： 什么是最左前缀原则？**



**问题： 索引是怎么提高查询速度的？**

**问题： MySQL索引是什么样的数据结构？**

**问题： MyISAM与InnoDB实现BTree索引的方式不同在哪？**


### 分库分表

**问题： 分库分表之后,id 主键如何处理？**

**问题： 列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询的问题。**

**问题： Mysql主从复制原理，mysql中如何做故障转移（容灾）**


### 其他奇葩问题

**问题： 数据库自增主键可能的问题**

**问题： 简单说一说drop、delete与truncate的区别**

**问题： varchar和char的使用场景？**

**问题： 数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）？**

**问题： MySQL 死锁发生的原因和解决**

**问题： MySQL 分别建立索引 a,b,c ，语句 select ...where b=x,c=x,a=x 能不能用到索引，建立联合索引能不能用到，a=x,b>x，能不能用到，用到几个索引？**

**问题： 大表如何优化？**

**问题： 面试官：谈谈你对Mysql的MVCC的理解？**

https://baijiahao.baidu.com/s?id=1629409989970483292&wfr=spider&for=pc


**问题：MySQL面试题：主从复制binlog延迟太多怎么办**

参考：https://blog.csdn.net/u010013573/article/details/88372909

主要技术点：

- 硬件资源瓶颈

  1、MySQL主从复制的过程其实就是二进制日志读取，传输，接收，解析执行的过程，故整个过程涉及到的主要资源包括：CPU，内存，磁盘IO，网络IO。

  2、主库的磁盘IO，内存，网络IO ；从库的磁盘IO，内存，网络IO。

- binlog日志量太大

  1、数据库是否以写操作为主，导致binlog日志很大
  
  2、分库分表，将写操作分散到各个数据库，各个数据库的复制流量相对较小，从而通过分而治之的方法来降低整体的延迟。


**问题：加快ALTER TABLE操作的速度**

1.两种方式：

* 一是在一台不提供服务的机器上执行ALTER TABLE操作，然后和提供服务的主库进行切换

* 二是通过“影子拷贝”，创建一张新表，然后通过重命名和删表操作交换两张表及里面的数据















